# C言語　オセロプログラム発展　
コンピュータにオセロの手を決めさせるプログラムを作成していきましょう。
     
  -  [プログラム作成](#プログラム作成)  
        - [1･2](#1,2)
        - [3･4](#3,4)
        - [5](#5)  
  - [プログラム例](#プログラム例)

  
## プログラム作成
以下の手順でコンピュータに手を決めさせましょう。

1. ユーザーに対人か、対コンピュータか選択させる
2. 対コンピュータが選択された場合、先手後手を選択させる
3. 全ての空白の場合を試行し、石を置ける場合は新たな配列に代入する
4. 乱数を利用して、新たな配列から1パターンを選択し、石を置く
5. ターンを入れ替える

### 1,2
``` C
void mode(){
   int mode;

   printf("ゲームモードを選択してください\n");
   printf("1:人間VS人間  2:人間VS単純AI\n");

   while(1){
      scanf("%d",&mode);
      if(mode!=1&&mode!=2){
         printf("もう一度入力してください\n");
      }else{
         break;
      }
   }
   switch(mode){
   case 1:
      whichAI=1;
      break;
   case 2:
      whichAI=2;
      while(1){
         printf("1:先手  2:後手\n");
         scanf("%d",&AIturn);
         AIturn-=1;
         if(AIturn!=0&&AIturn!=1){
            printf("もう一度入力してください\n");
         }else{
            break;
         }
      }
   }			
}	
```
上のコードは、対人か対コンピュータか選択する**mode関数**です。  
-  変数`mode`の値によって処理が変わります。  
   -  1のとき ： 対人  
   -  2のとき ： 対コンピュータ  
   -  それ以外： もう一度入力させる
----------------------
これ以降、変数`whichAI`・変数`AIturn`という2つの変数が登場します。  
泣く泣くグローバル変数にしています（戻り値は1つしか返せないので）。  
-  変数`mode`は、値が**1･2**である場合に、  
それぞれ変数`whichAI`の値を**1・2**と変更している。  
-  変数`whichAI`の値が2である場合（**対コンピュータの場合**）、先手後手を選択させます。  
（入力値を **-1** することで、、意味的に分かりやすくしている）  
   -  **0**のとき ： ユーザーが先手  
   -  **1**のとき ： コンピュータが先手  
   -  それ以外： もう一度入力させる 

### 3,4
``` C
void AIplay(int nowcolor2){
   int i,j,m=0,n,k,x,y,z,a[20][2];
   for(x=0;x<8;x++){
      for(y=0;y<8;y++){
         if (color[x][y] == 1 || color[x][y] == 2) {
            continue;
         }

         for (i = -1; i <= 1; i++) {
            for (j = -1; j <= 1; j++) {

               /*置いたところは無視*/
               if (i == 0 && j == 0) {
                  continue;
               }
               /*隣が自色は無視*/
               if (color[i+x][j+y]==nowcolor2) {
                  continue;
               }
               /*各方向に1マスずつ確認*/
               for (k = 1; k < 8; k++) {

                  /*盤内だけでチェック*/
                  if (x + i * k >= 0 && x + i * k < 8 && y + j * k >= 0 && y + j * k < 8) {
										
                     /*空白があった場合はそれ以上試行する必要なし*/
                     if (color[x + i * k][y + j * k] == 0) {
                        break;
                     }
                     else if (color[x + i * k][y + j * k] == nowcolor2) {
                        a[m][0]=x;
                        a[m][1]=y;
                        m+=1;
                     }
                  }
               }
            }
         }
      }
   }
   srand(time(NULL));
   z=rand()%m;	
   for (i = -1; i <= 1; i++) {
      for (j = -1; j <= 1; j++) {

         /*置いたところは無視*/
         if (i == 0 && j == 0) {
            continue;
         }
         /*隣が自色は無視*/
         if (color[i+a[z][0]][j+a[z][1]]==nowcolor2) {
            continue;
         }
         /*各方向に1マスずつ確認*/
         for (k = 1; k < 8; k++) {

            /*盤内だけでチェック*/
            if (a[z][0] + i * k >= 0 && a[z][0] + i * k < 8 && a[z][1] + j * k >= 0 && a[z][1] + j * k < 8) {
										
               /*空白があった場合はそれ以上試行する必要なし*/
               if (color[a[z][0] + i * k][a[z][1] + j * k] == 0) {
                  break;
               }
               /*自色を見つけたらそこまでのコマをひっくり返す*/
               else if (color[a[z][0] + i * k][a[z][1] + j * k] == nowcolor2) {
                  color[a[z][0]][a[z][1]] = nowcolor2;
                  for (n = 1; n <= k; n++) {
                     color[a[z][0] + i * n][a[z][1] + j * n] = nowcolor2;
                  }
                  break;
               }
            }
         }	
      }	
   }
}
```
上のコードは、コンピュータがどこに石を置くかを決めて敵色の石をひっくり返す処理まで行う`AIplay関数`です。  
基本は`check関数`と全く同じであるので、不明な点があれば復習してください。

-  5～7行目では、**置こうとした石のマスが空白でない場合**に、以降のプログラムをスキップして`y`のループに戻っている。
--------------------
数多のif文を乗り越え、**自色の石を置ける空マス**を発見できました。  
-  空白に石が置ける場合は、二次元配列`a`にその座標を代入する。  
      - **（変数`m`の値+1）** は、**石を置ける空白の数**を表している。  
    `例：m=2のとき、石を置けるパターンは3通り`  
      -  `a[m][0]`には石を置ける座標の**x座標**を、`a[m][1]` には石を置ける座標の**y座標**を代入する。  
      - この後の調整のために、**`m`の値を+1**する。  
--------------------
以下の処理では、**どの空白に石を置くかを選択**し、石をひっくり返していきます。  
-  42行目では、**0～(変数`m-1`)** の範囲で**乱数（整数）** を生成し、変数`z`に代入する。

以下の処理からいよいよ、**選ばれた空白の座標に石を置く処理**を行います。  
基本は`check関数`と全く同じであるので、不明な点があれば復習してください。

-  座標は二次元配列`a`で指定されていることに注意してください。

### 5
``` C
/*描写*/
display();
mode();
badpoint=0;
nowcolor=2;

while (1){
   if (nowcolor == 2) {
      printf("黒のターンです\n");
      if(AIturn==1){
         printf("AIのターンです\n5秒ほどお待ちください\n");
         sleep(5);
      }
   }
   else if (nowcolor == 1) {
      printf("白のターンです\n");
      if(AIturn==1){
         printf("AIのターンです\n5秒ほどお待ちください\n");
         sleep(5);
      }
   }
   /*始める*/
   if(whichAI==1){
      if(badpoint!=0){
         printf("置ける場所はありません");
         sleep(3);
      }else{
         play(nowcolor);
      }		
   }else if(whichAI==2){
      if(AIturn==0){
         if(badpoint!=0){
            printf("置ける場所はありません");
            sleep(3);
         }else{
            play(nowcolor);
         }
         AIturn=1;
      }else if(AIturn==1){
         if(badpoint!=0){
            printf("置ける場所はありません");
            sleep(3);
         }else{
            AIplay(nowcolor);
         }
         AIturn=0;   	
      }
   }
}
```
上のコードは、`mode関数`や`AIplay`関数を踏まえて、前回からmain関数について書き換えた部分のプログラムです。

-  攻守交替プログラム、ユーザーが「対人」を選択したときのプログラムについては、前回資料を参照。
-------------------------
以下の解説は、**ユーザーが「対AI」を選択した場合**のものです。  
-  ユーザーのターンのとき（変数`AIturn=0`のとき）は、  
変数`badpoint`の値が0である場合は、**play関数**を実行する。

-  **AIのターンのとき**（変数`AIturn=1`のとき）は、AIのターンであることを出力し、  
まるで**AIが考えているかのように**`sleep関数`で5秒スリープさせている。  
- その後、変数`badpoint`の値が0である場合は、**AIplay関数**を実行する。

## プログラム例
[プログラム例](Osero_vsAI.md)    
上のコードは、**オセロゲームを対コンピュータで楽しめる**プログラムです。  
これまで学習したことが全て組み合わさっています。ぜひ遊んでみて下さい！
