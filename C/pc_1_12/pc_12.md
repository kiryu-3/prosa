# C言語　第12回　
第12回では、本格的なオセロゲームができるプログラムを作成していきましょう。
     
  -  [プログラム作成](#プログラム作成)  
        - [4･5-1](#4･5-1)
        - [4･5-2](#4･5-2)
          - [変数の意味](#変数の意味)
          - [縦横斜め方向に1マスずつ確認](#縦横斜め方向に1マスずつ確認)  
          - [置けるかの判定と石をひっくり返す処理](#置けるかの判定と石をひっくり返す処理)  
        - [6-1](#6-1)  
          - [変数の意味](#変数の意味)
          - [盤内の空マスの確認](#盤内の空マスの確認)  
          - [続行判断](#続行判断)   
        - [6-2](#6-2) 
  - [プログラム例](#プログラム例)
  - [発展プログラム](#発展プログラム)
  
  ---
## プログラム作成
プログラムの処理の順番は、以下の通りとします。

1. 盤面をリセットし、初期石を置く
2. 標準入力で石を置く座標を入力する
3. 盤内かつすでに石が置かれていないか確認
4. 縦横斜め方向に1マスずつ確認
5. 敵色を挟んで自色があった場合はそれまでの石を自色に変える
6. 続行可能か判断する
7. 続行不可になればマスの数を数える

今回は、上の4～6のプログラムを考えていきます。

### 4･5-1
``` C
void play(int nowcolor2) {
   int i,j,flag;
   /*入力*/
   while (1){
      printf("縦＝");
      scanf("%d",&i);
		
      printf("横＝");
      scanf("%d",&j);


      if (i<0||i>7||j<0||j>7) {
         printf("盤外です\n");
         continue;
      }else if(color[i][j] == 1 || color[i][j] == 2){
         printf("すでにコマが置かれています\n");
         continue;
      }else{
         flag=put(i, j,nowcolor2);
         if (flag == 0) {
            break;
         }else if (flag == 1) {
            printf("選択した場所には置けません\n");
         }
      }
   }
}
```
上のコードは、前回述べたように、新たな関数を呼び出している`play関数`のプログラムです。  
-  指定した場所が盤内で、なおかつ石がまだ置かれていない場合、`put関数`を実行する。  
  引数には**指定した場所の座標**と、**現在の色**を指定する。  
-  戻り値である**変数`flag`の値が1**となってしまった場合、選択した場所には石を置けないことを示す。  

### 4･5-2
``` C
int put(int x, int y,int nowcolor3) {
   int i,j,n,k;
   int flag=1;
   /*置けるかチェックしつつひっくり返す*/
   for (i = -1; i <= 1; i++) {
      for (j = -1; j <= 1; j++) {

         /*置いたところは無視*/
         if (i == 0 && j == 0) {
            continue;
         }
         /*隣が自色は無視*/
         if (color[i+x][j+y]==nowcolor3) {
            continue;
         }

         /*各方向に1マスずつ確認*/
         for (k = 1; k < 8; k++) {

            /*盤内だけでチェック*/
            if (x + i * k >= 0 && x + i * k < 8 && y + j * k >= 0 && y + j * k < 8) {
					
               /*空白があった場合はそれ以上試行する必要なし*/
               if (color[x + i * k][y + j * k] == 0) {
                  break;
               }
                /*自色を見つけたらそこまでのコマをひっくり返す*/
                  else if (color[x + i * k][y + j * k] == nowcolor3) {
                     /*コマを置き自色に変える*/
                     color[x][y] = nowcolor3;
                     for (n = 1; n <= k; n++) {
                     color[x + i * n][y + j * n] = nowcolor3;
                  }
                  flag=0;
                  break;
                }
            }
					
         }
      }
   }
   return flag;
}
```
上のコードは、盤の空白に石が置けるかどうかを判断し、  
石が置ける場合は挟んだ敵色の石をひっくり返す処理を行う`put関数`のプログラムです。  

#### ＜変数の意味＞
・仮引数 `x,y` は、指定した座標（`x`が行、`y`が列）を表している。  
・仮引数`nowcolor3`は、現在の石の色を表している。  
・変数`i , j`は、**縦横斜め8方向**の内どの方向を確認するかを定めるために必要である。  
　`例：i =-1 , j =1のとき、左斜め上を指定`  
・変数`n`は、何マス先の自色の石で挟むかを決めるために必要である。  
・変数`k`は、変数`n`で定めた石と指定した石で敵色の石をひっくり返すときに必要である。  
・変数`flag`は、石が置ける場合・置けない場合に、それぞれ変数`flag`の値を**0・1**と変更している。初期値は**1**である。  

#### ＜縦横斜め方向に1マスずつ確認＞
・ 5･6行目では、**どの方向も指定していない**ので、continue文でスキップしている。  
・ 9･10行目は、**隣が自色である方向**なので、continue文でスキップしている。    

・18行目からのfor文の中では、**いくつ先の石で敵色の石を挟むか**を、1マスずつ確認している。  
・21行目からのif文は、**盤内の話だけで完結**するために必要な処理である。

#### ＜置けるかの判定と石をひっくり返す処理＞
・24～26行目は、調べたい方向に**自色が現れる前に空白があった場合**、for文（`k`のループ）をスキップする処理である。  
・28行目以降は、**調べたい方向に自色が現れた場合**の処理である。  
　　①**初めて**置きたい場所に石を置くよう指示する（30行目）  
　　②挟んだ敵色の石を自色に変える（31～33行目）。  
・**石が置ける場合**に限り、変数`flag`の値を0にする。最終的に`flag`を戻り値とする。  

### 6-1
``` C
int check(int badpoint,int nowcolor2){
   int k,i,j,x,y,flag=1;
   for (x = 0; x < 8; x++) {
      for (y = 0; y < 8; y++) {
         for (i = -1; i <= 1; i++) {
            for (j = -1; j <= 1; j++) {
               if (color[x][y] == 1 || color[x][y] == 2) {
                  continue;
               }
               flag = 1;

               /*置いたところは無視*/
               if (i == 0 && j == 0) {
                  continue;
               }
               /*隣が自色は無視*/
               if (color[i+x][j+y]==nowcolor2) {
                   continue;
               }
               /*各方向に1マスずつ確認*/
               for (k = 1; k < 8; k++) {

                  /*盤内だけでチェック*/
                   if (x + i * k >= 0 && x + i * k < 8 && y + j * k >= 0 && y + j * k < 8) {
									
                     /*空白があった場合はそれ以上試行する必要なし*/
                     if (color[x + i * k][y + j * k] == 0) {
                        break;
                     }
                     /*自色を見つけたらそこまでのコマをひっくり返す*/
                     else if (color[x + i * k][y + j * k] == nowcolor2) {
                        flag=0;
                        goto end;
                     }
                  }
               }
            }
         }
      }	
   }
   end:
   if(flag == 1) {
      badpoint+=1;
   }else if(flag==0){
      badpoint=0;
   }
   flag==1;
   return badpoint;
}
```
上のコードは、本格的にオセロの続行判断を行う **`check関数`** のプログラムです。

まずは、main関数内で以下のようにして`check関数`を呼び出します。

``` C
badpoint=check(badpoint,nowcolor);
if(badpoint==2){
   break;
}
```

-  変数`badpoint`の値は初めは**0**であるが、**2**となった場合（**両者とも駒が置けない状態となった場合**）は、  
main関数のwhile文からbreakで抜け出す。

#### ＜変数の意味＞
・仮引数 `badpoint` は、**駒が置けない状態が何回続いているか**を表している。  
・put関数の中では仮引数だった変数`x,y`は、盤内すべての座標を調べるために必要である。  
・変数`flag`は、その色で続行可・続行不可である場合、それぞれ変数`flag`の値を**0・1**と変更している。初期値は**1**である。  
・その他の変数の意味は（一部名称が違うものもあるが）`put関数`と意味は変わらない。

#### ＜盤内の空マスの確認＞
盤内に空マスがあった場合に、それが自色の石を置ける空マスなのかを確認します。

・7～9行目では、**石が置かれている場合**はその座標では続行判断をする意味がないのでcontinue文でスキップしている。  
・10行目からの意味は、`put関数`と同じである。

#### ＜続行判断＞
数多のif文を乗り越え、**自色の石を置ける空マス**を発見できました。

・**ある空マスで石が置ける場合**に限り、変数`flag`の値を0にする。  
・**goto文**を用いて、`x`のforループ～`k`のforループまでの5つのforループから抜け出す。
  
ラベルとして指定した`end`の位置までループすることができました。  
石が置けた場合と、どこにも置けなかった場合で処理が分かれます。

・**石をどこにも置けなかった場合**は、変数`flag`の値は**1**のままである。変数`badpoint`の値を **+1** する。  
・**石がどこかに置けた場合**は、変数`flag`の値は**0**に更新される。変数`badpoint`の値を（0ではない場合もあるので）**0**にする。  
・最終的に変数`badpoint`を戻り値とする。

### 6-2
``` C
/*始める*/
if(badpoint!=0){
	printf("置ける場所はありません");
	sleep(3);
}else{
	play(nowcolor);
}		
```

上のコードは、main関数内で`check関数`で得られた変数`badpoint`の値から、`play関数`を実行するか判断するプログラムです。  
-  **変数`badpoint`の値が0ではない場合**（原則**1**の場合）は石は置けない状態であることを出力する。  
-  **sleep関数**を用いて3秒スリープさせることで、急に次のターンに移行することを防止している。  
-  変数`badpoint`の値が**0**である場合は、`play関数`を実行する。

**※`sleep関数`については、[第12回補足資料](pc_12+.md)にて解説しています** 

## プログラム例
[プログラム例](Osero_vsUSER.md)    
上のコードは、**オセロゲームを対人で楽しめる**プログラムです。  
これまで学習したことが全て組み合わさっています。ぜひ遊んでみて下さい！  

## 発展プログラム  
[第12回発展資料](pc_12++.md)    
対人だけではなく対コンピュータ（優秀ではないですが）と戦いたい人向けに、発展用プログラムについて解説しています！
